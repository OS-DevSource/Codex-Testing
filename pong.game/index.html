<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Neon Pong</title>
    <style>
      :root {
        --bg-gradient: radial-gradient(
          circle at top left,
          #1a1133,
          #05030f 55%,
          #030110 100%
        );
        --surface: rgba(17, 11, 28, 0.72);
        --glow-blue: #5bc2ff;
        --glow-magenta: #ff4dff;
        --glow-green: #44ffb9;
        --text-primary: #f2f5ff;
        --divider: rgba(242, 245, 255, 0.45);
        --pulse-left: 0;
        --pulse-right: 0;
        --pulse-top: 0;
        --pulse-bottom: 0;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        color-scheme: dark;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        display: grid;
        place-items: center;
        background: var(--bg-gradient);
        color: var(--text-primary);
        -webkit-font-smoothing: antialiased;
      }

      .game-shell {
        width: min(96vw, 980px);
        display: grid;
        gap: 1.5rem;
        padding: 2rem clamp(1.5rem, 2vw, 3rem);
        border-radius: 24px;
        background: linear-gradient(
          145deg,
          rgba(255, 255, 255, 0.05),
          rgba(0, 0, 0, 0.35)
        );
        border: 1px solid rgba(255, 255, 255, 0.08);
        box-shadow:
          0 20px 60px rgba(0, 0, 0, 0.45),
          0 0 60px rgba(91, 194, 255, 0.2);
        backdrop-filter: blur(16px);
      }

      .hud,
      .footer {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 1rem;
      }

      .hud {
        font-size: clamp(1.1rem, 2vw, 1.5rem);
      }

      .scoreboard {
        display: flex;
        align-items: center;
        gap: 1rem;
        font-weight: 700;
        letter-spacing: 0.08em;
        text-transform: uppercase;
      }

      .scoreboard span {
        text-shadow: 0 0 12px rgba(91, 194, 255, 0.8);
      }

      .scoreboard .divider {
        color: var(--divider);
        text-shadow: none;
      }

      .ghost-button,
      .primary-button {
        font-size: 0.95rem;
        padding: 0.65rem 1.5rem;
        border-radius: 999px;
        border: 1px solid transparent;
        cursor: pointer;
        text-transform: uppercase;
        letter-spacing: 0.12em;
        font-weight: 600;
        transition:
          transform 180ms ease,
          box-shadow 200ms ease,
          border-color 200ms ease;
      }

      .ghost-button {
        background: rgba(255, 255, 255, 0.08);
        color: var(--text-primary);
        border-color: rgba(255, 255, 255, 0.12);
      }

      .ghost-button:hover,
      .primary-button:hover {
        transform: translateY(-2px);
      }

      .primary-button {
        background: linear-gradient(
          90deg,
          var(--glow-blue),
          var(--glow-magenta)
        );
        color: #0e041f;
        box-shadow: 0 10px 30px rgba(91, 194, 255, 0.5);
      }

      .canvas-wrapper {
        position: relative;
        border-radius: 18px;
        padding: clamp(1rem, 2vw, 2rem);
        background: var(--surface);
        box-shadow: inset 0 0 40px rgba(91, 194, 255, 0.2);
      }

      .canvas-wrapper::before,
      .canvas-wrapper::after {
        content: "";
        position: absolute;
        inset: clamp(0.4rem, 1vw, 0.65rem);
        border-radius: 12px;
        pointer-events: none;
        transition: opacity 220ms ease;
      }

      .canvas-wrapper::before {
        background:
          radial-gradient(
            circle at 10% 50%,
            rgba(91, 194, 255, calc(var(--pulse-left) * 0.45)) 0 45%,
            transparent 65%
          ),
          radial-gradient(
            circle at 90% 50%,
            rgba(255, 77, 255, calc(var(--pulse-right) * 0.45)) 0 45%,
            transparent 65%
          );
        opacity: max(var(--pulse-left), var(--pulse-right));
      }

      .canvas-wrapper::after {
        background:
          radial-gradient(
            circle at 50% 8%,
            rgba(91, 194, 255, calc(var(--pulse-top) * 0.35)) 0 45%,
            transparent 70%
          ),
          radial-gradient(
            circle at 50% 92%,
            rgba(68, 255, 185, calc(var(--pulse-bottom) * 0.35)) 0 45%,
            transparent 70%
          );
        opacity: max(var(--pulse-top), var(--pulse-bottom));
      }

      canvas {
        width: 100%;
        height: auto;
        display: block;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: radial-gradient(
          circle at center,
          rgba(5, 12, 32, 0.9),
          rgba(1, 3, 9, 0.95)
        );
        box-shadow: inset 0 0 60px rgba(91, 194, 255, 0.35);
      }

      .overlay {
        position: absolute;
        inset: 0;
        display: grid;
        place-items: center;
        text-align: center;
        padding: 2rem;
        background: rgba(8, 3, 18, 0.85);
        border-radius: 12px;
        opacity: 1;
        visibility: visible;
        transition:
          opacity 200ms ease,
          visibility 200ms ease;
      }

      .overlay.hidden {
        opacity: 0;
        visibility: hidden;
      }

      .overlay h1 {
        font-size: clamp(2rem, 3.5vw, 3.5rem);
        margin-bottom: 0.5rem;
        text-transform: uppercase;
        letter-spacing: 0.2em;
        text-shadow:
          0 0 20px rgba(91, 194, 255, 0.9),
          0 0 40px rgba(255, 77, 255, 0.6);
      }

      .overlay p {
        max-width: 360px;
        margin-bottom: 1.5rem;
        line-height: 1.4;
        color: rgba(242, 245, 255, 0.8);
      }

      .footer {
        color: rgba(242, 245, 255, 0.65);
        font-size: 0.9rem;
      }

      .footer p {
        margin: 0;
      }

      @media (max-width: 700px) {
        .game-shell {
          padding: 1.5rem;
        }

        canvas {
          height: 70vh;
        }
      }
    </style>
  </head>
  <body>
    <main class="game-shell">
      <header class="hud">
        <div class="scoreboard">
          <span id="playerScore">0</span>
          <span class="divider">:</span>
          <span id="cpuScore">0</span>
        </div>
        <button id="restart" class="ghost-button" type="button">Restart</button>
      </header>

      <section class="canvas-wrapper">
        <canvas id="game" width="900" height="600"></canvas>
        <div id="overlay" class="overlay">
          <h1>Neon Pong</h1>
          <p>Move your paddle with the mouse or arrow keys.</p>
          <button id="start" class="primary-button" type="button">Play</button>
        </div>
      </section>

      <footer class="footer">
        <p>
          First to 7 points wins. Built with vanilla JavaScript and lots of
          glow.
        </p>
      </footer>
    </main>

    <script>
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");

      const overlay = document.getElementById("overlay");
      const startButton = document.getElementById("start");
      const restartButton = document.getElementById("restart");
      const playerScoreEl = document.getElementById("playerScore");
      const cpuScoreEl = document.getElementById("cpuScore");
      const overlayTitle = overlay.querySelector("h1");
      const overlayMessage = overlay.querySelector("p");

      const PADDLE = {
        width: 14,
        height: 120,
        minHeight: 90,
        maxHeight: 160,
        speed: 540,
      };

      const BALL = {
        radius: 10,
        baseSpeed: 420,
        maxSpeed: 980,
      };

      const WIN_SCORE = 7;

      const player = {
        x: 24,
        y: canvas.height / 2 - PADDLE.height / 2,
        width: PADDLE.width,
        height: PADDLE.height,
        targetY: canvas.height / 2,
      };

      const cpu = {
        x: canvas.width - 24 - PADDLE.width,
        y: canvas.height / 2 - (PADDLE.height - 40) / 2,
        width: PADDLE.width,
        height: PADDLE.height - 40,
        drift: 0,
      };

      const ball = {
        x: canvas.width / 2,
        y: canvas.height / 2,
        vx: 0,
        vy: 0,
        speed: BALL.baseSpeed,
      };

      const state = {
        running: false,
        gameOver: false,
        scores: {
          player: 0,
          cpu: 0,
        },
        lastDirection: Math.random() > 0.5 ? 1 : -1,
      };

      const keys = {
        up: false,
        down: false,
      };

      let lastTime = performance.now();
      requestAnimationFrame(loop);

      function loop(timestamp) {
        const delta = Math.min((timestamp - lastTime) / 1000, 0.05);
        lastTime = timestamp;

        update(delta);
        render();

        requestAnimationFrame(loop);
      }

      function update(delta) {
        if (!state.running) {
          applyIdleGlow(delta);
          return;
        }

        updatePlayer(delta);
        updateCpu(delta);
        updateBall(delta);
      }

      function updatePlayer(delta) {
        if (keys.up) {
          player.targetY -= PADDLE.speed * delta;
        } else if (keys.down) {
          player.targetY += PADDLE.speed * delta;
        }

        const halfHeight = player.height / 2;
        const clampedTarget = clamp(
          player.targetY,
          halfHeight,
          canvas.height - halfHeight,
        );
        player.targetY = clampedTarget;

        const center = player.y + halfHeight;
        const distance = clampedTarget - center;
        const move =
          Math.sign(distance) *
          Math.min(Math.abs(distance), PADDLE.speed * delta * 0.9);
        player.y += move;
      }

      function updateCpu(delta) {
        const trackingStrength =
          0.9 - Math.min(ball.speed / BALL.maxSpeed, 0.7);
        const ballAhead = ball.vx > 0;
        const targetCenter = ballAhead ? ball.y + cpu.drift : canvas.height / 2;

        const halfHeight = cpu.height / 2;
        const desired = clamp(
          targetCenter,
          halfHeight + 16,
          canvas.height - halfHeight - 16,
        );
        const center = cpu.y + halfHeight;
        const diff = desired - center;
        const moveAmount =
          Math.sign(diff) *
          Math.min(Math.abs(diff), PADDLE.speed * trackingStrength * delta);
        cpu.y += moveAmount;

        cpu.drift = lerp(cpu.drift, randomRange(-40, 40), 0.005);
      }

      function updateBall(delta) {
        ball.x += ball.vx * delta;
        ball.y += ball.vy * delta;

        if (
          ball.y - BALL.radius <= 0 ||
          ball.y + BALL.radius >= canvas.height
        ) {
          ball.vy *= -1;
          ball.y = clamp(ball.y, BALL.radius, canvas.height - BALL.radius);
          flashGlow(ball.y < canvas.height / 2 ? "top" : "bottom");
        }

        if (ball.vx < 0 && intersects(player)) {
          bounceOffPaddle(player, true);
          flashGlow("left");
        } else if (ball.vx > 0 && intersects(cpu)) {
          bounceOffPaddle(cpu, false);
          flashGlow("right");
        }

        if (ball.x < -BALL.radius) {
          awardPoint("cpu");
        } else if (ball.x > canvas.width + BALL.radius) {
          awardPoint("player");
        }
      }

      function applyIdleGlow(delta) {
        cpu.drift = lerp(cpu.drift, 0, 0.03);
        const idleWobble = Math.sin(performance.now() / 600) * 0.25;
        ball.x = lerp(
          ball.x,
          canvas.width / 2 + Math.sin(performance.now() / 1000) * 80,
          delta * 2.5,
        );
        ball.y = lerp(
          ball.y,
          canvas.height / 2 + idleWobble * 120,
          delta * 2.5,
        );
      }

      function bounceOffPaddle(paddle, isLeftPaddle) {
        const relativeIntersect = paddle.y + paddle.height / 2 - ball.y;
        const normalized = relativeIntersect / (paddle.height / 2);
        const bounceAngle = normalized * (Math.PI / 3);
        const newSpeed = clamp(
          ball.speed * 1.05,
          BALL.baseSpeed,
          BALL.maxSpeed,
        );
        const horizontalDirection = isLeftPaddle ? 1 : -1;

        ball.speed = newSpeed;
        ball.vx = newSpeed * Math.cos(bounceAngle) * horizontalDirection;
        ball.vy = newSpeed * -Math.sin(bounceAngle);

        const paddleEdge = isLeftPaddle
          ? paddle.x + paddle.width + BALL.radius
          : paddle.x - BALL.radius;
        ball.x = paddleEdge;
      }

      function awardPoint(side) {
        state.scores[side] += 1;
        updateScoreboard();

        if (state.scores[side] >= WIN_SCORE) {
          endGame(side === "player");
        } else {
          state.running = false;
          state.lastDirection = side === "player" ? -1 : 1;
          setTimeout(() => {
            resetRound(state.lastDirection);
            state.running = true;
          }, 700);
        }
      }

      function endGame(playerWon) {
        state.gameOver = true;
        state.running = false;
        const title = playerWon ? "Victory!" : "CPU Wins";
        const message = playerWon
          ? "You dominated the arena. Click play to run it back."
          : "The CPU outplayed you this time. Study the angles and try again!";
        showOverlay(title, message, "Play Again");
      }

      function resetRound(direction = 1) {
        ball.x = canvas.width / 2;
        ball.y = canvas.height / 2;
        ball.speed = BALL.baseSpeed;
        const angle = randomRange(-Math.PI / 4, Math.PI / 4);
        ball.vx = ball.speed * Math.cos(angle) * direction;
        ball.vy = ball.speed * Math.sin(angle);

        player.y = canvas.height / 2 - player.height / 2;
        player.targetY = canvas.height / 2;
        cpu.y = canvas.height / 2 - cpu.height / 2;
        cpu.drift = 0;
      }

      function updateScoreboard() {
        playerScoreEl.textContent = state.scores.player;
        cpuScoreEl.textContent = state.scores.cpu;
      }

      function intersects(paddle) {
        return (
          ball.x - BALL.radius < paddle.x + paddle.width &&
          ball.x + BALL.radius > paddle.x &&
          ball.y - BALL.radius < paddle.y + paddle.height &&
          ball.y + BALL.radius > paddle.y
        );
      }

      function startGame() {
        hideOverlay();
        state.running = true;
        state.gameOver = false;
        state.lastDirection = Math.random() > 0.5 ? 1 : -1;
        resetRound(state.lastDirection);
      }

      function restartGame() {
        state.scores.player = 0;
        state.scores.cpu = 0;
        updateScoreboard();
        startGame();
      }

      function showOverlay(title, message, buttonText) {
        overlayTitle.textContent = title;
        overlayMessage.textContent = message;
        startButton.textContent = buttonText;
        overlay.classList.remove("hidden");
      }

      function hideOverlay() {
        overlay.classList.add("hidden");
      }

      function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        drawCenterLine();
        drawGlowCircle(ball.x, ball.y, 24, "rgba(91, 194, 255, 0.18)");
        drawBall();
        drawPaddle(player, "rgba(91, 194, 255, 0.85)");
        drawPaddle(cpu, "rgba(255, 77, 255, 0.85)");
      }

      function drawCenterLine() {
        const segmentHeight = 24;
        const gap = 18;
        ctx.fillStyle = "rgba(91, 194, 255, 0.25)";
        for (
          let y = gap;
          y < canvas.height - segmentHeight;
          y += segmentHeight + gap
        ) {
          ctx.fillRect(canvas.width / 2 - 2, y, 4, segmentHeight);
        }
      }

      function drawBall() {
        ctx.beginPath();
        ctx.fillStyle = "#ffffff";
        ctx.shadowColor = "rgba(91, 194, 255, 0.9)";
        ctx.shadowBlur = 25;
        ctx.arc(ball.x, ball.y, BALL.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }

      function drawPaddle(paddle, color) {
        ctx.shadowColor = color;
        ctx.shadowBlur = 25;
        ctx.fillStyle = "rgba(6, 15, 36, 0.65)";
        ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
        ctx.shadowBlur = 0;
        ctx.strokeStyle = color;
        ctx.lineWidth = 2.5;
        ctx.strokeRect(
          paddle.x - 1.5,
          paddle.y - 1.5,
          paddle.width + 3,
          paddle.height + 3,
        );
        ctx.fillStyle = color;
        ctx.globalAlpha = 0.18;
        ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
        ctx.globalAlpha = 1;
      }

      function drawGlowCircle(x, y, radius, color) {
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
        gradient.addColorStop(0, color);
        gradient.addColorStop(1, "rgba(91, 194, 255, 0)");
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();
      }

      function flashGlow(side) {
        const root = document.documentElement;
        const prop = `--pulse-${side}`;
        root.style.setProperty(prop, "1");
        setTimeout(() => root.style.setProperty(prop, "0"), 140);
      }

      function clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
      }

      function lerp(start, end, t) {
        return start + (end - start) * t;
      }

      function randomRange(min, max) {
        return Math.random() * (max - min) + min;
      }

      canvas.addEventListener("mousemove", (event) => {
        const rect = canvas.getBoundingClientRect();
        const scaleY = canvas.height / rect.height;
        const y = (event.clientY - rect.top) * scaleY;
        player.targetY = y;
      });

      window.addEventListener("keydown", (event) => {
        if (event.key === "ArrowUp" || event.key === "w") {
          keys.up = true;
        }
        if (event.key === "ArrowDown" || event.key === "s") {
          keys.down = true;
        }
        if (
          !state.running &&
          !state.gameOver &&
          (event.key === " " || event.key === "Enter")
        ) {
          startGame();
        }
      });

      window.addEventListener("keyup", (event) => {
        if (event.key === "ArrowUp" || event.key === "w") {
          keys.up = false;
        }
        if (event.key === "ArrowDown" || event.key === "s") {
          keys.down = false;
        }
      });

      startButton.addEventListener("click", () => {
        if (state.gameOver) {
          restartGame();
        } else {
          startGame();
        }
      });

      restartButton.addEventListener("click", () => {
        restartGame();
      });

      showOverlay(
        "Neon Pong",
        "Move your paddle with the mouse or arrow keys. First to 7 points wins.",
        "Play",
      );
      updateScoreboard();
      resetRound(state.lastDirection);
    </script>
  </body>
</html>
